<?php

namespace App\Http\Controllers;

use App\Models\Restitution;
use App\Models\Xcaution;
use App\Models\Deconsignation;
use App\Models\Consignation;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Validator;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\DB;
use Carbon\Carbon;
use Barryvdh\DomPDF\Facade\Pdf as PDF;

class RestitutionController extends Controller
{
    public function index()
    {
        // Order by creation date descending for "Derniers lus"
        $restitutions = Restitution::orderBy('created_at', 'desc')->get();
        return response()->json($restitutions);
    }    public function store(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'xsite_0'     => 'required|string|max:255',
            'xclient_0'   => 'required|string|max:255',
            'xraison_0'   => 'nullable|string|max:255',
            'xcin_0'      => [
                'required',
                'regex:/^[A-Za-z]{1,2}\d{4,8}$/'
            ],
            'xvalsta_0'   => 'required|in:1,2',
            'montant'     => 'required|numeric|min:0.01',
            'xdate_0'     => 'required|string|date_format:d/m/Y',
            'xheure_0'    => 'required|string|date_format:H:i',
            'caution_ref' => 'nullable|string|max:255',
            'remarques'   => 'nullable|string|max:1000',
        ]);

        if ($validator->fails()) {
            return response()->json(['errors' => $validator->errors()], 422);
        }

        $validatedData = $validator->validated();

        // Force xvalsta_0 to 1 (non validé) on creation
        $validatedData['xvalsta_0'] = 1;

        // Apply business logic validation
        $validationResult = $this->validateRestitutionLogic(
            $validatedData['xclient_0'],
            $validatedData['xsite_0'],
            $validatedData['montant']
        );

        if (!$validationResult['success']) {
            return response()->json([
                'success' => false,
                'message' => $validationResult['message'],
                'error_type' => $validationResult['error_type'] ?? 'validation_error',
                'balance_info' => $validationResult['balance_info'] ?? null
            ], 422);
        }

        // No need to generate xnum_0 as it will be auto-generated by the model
        // if not provided in the request

        // Convert date format from d/m/Y to Y-m-d
        $validatedData['xdate_0'] = Carbon::createFromFormat('d/m/Y', $validatedData['xdate_0'])->format('Y-m-d');

        $restitution = Restitution::create($validatedData);

        // Trigger comprehensive balance recalculation if restitution is created as validated
        if (isset($validatedData['xvalsta_0']) && $validatedData['xvalsta_0'] == 2) {
            try {
                \App\Models\Csolde::recalculateBalance($restitution->xclient_0, $restitution->xsite_0);
                Log::info("Balance recalculated after validated restitution creation: Client={$restitution->xclient_0}, Site={$restitution->xsite_0}");
            } catch (\Exception $e) {
                Log::error("Error recalculating balance after validated restitution creation: " . $e->getMessage());
            }
        }

        return response()->json([
            'message' => 'Restitution créée avec succès',
            'restitution' => $restitution
        ], 201);
    }    public function show($xnum_0)
    {
        $restitution = Restitution::where('xnum_0', $xnum_0)->first();
        if (!$restitution) {
            return response()->json(['message' => 'Restitution non trouvée.'], 404);
        }
        return response()->json($restitution);
    }    public function update(Request $request, $xnum_0)
    {
        $restitution = Restitution::where('xnum_0', $xnum_0)->first();
        if (!$restitution) {
            return response()->json(['message' => 'Restitution non trouvée.'], 404);
        }

        // Check if this is a validation request (updating xvalsta_0 to 2)
        $isValidationRequest = $request->has('xvalsta_0') && $request->xvalsta_0 == 2;
        
        Log::info("Restitution update request received", [
            'xnum_0' => $xnum_0,
            'request_data' => $request->all(),
            'is_validation_request' => $isValidationRequest,
            'current_xvalsta_0' => $restitution->xvalsta_0
        ]);

        if ($isValidationRequest) {
            // For validation requests, validate all required fields
            $validator = Validator::make($request->all(), [
                'xcin_0' => [
                    'required',
                    'regex:/^[A-Za-z]{1,2}\d{4,8}$/'
                ],
                'montant' => 'required|numeric|min:0',
                'xvalsta_0' => 'required|in:1,2'
            ]);

            if ($validator->fails()) {
                return response()->json(['errors' => $validator->errors()], 422);
            }

            // Apply business logic validation before validation
            $validationResult = $this->validateRestitutionLogic(
                $restitution->xclient_0,
                $restitution->xsite_0,
                $request->montant
            );

            if (!$validationResult['success']) {
                return response()->json([
                    'success' => false,
                    'message' => $validationResult['message'],
                    'error_type' => $validationResult['error_type'] ?? 'validation_error',
                    'balance_info' => $validationResult['balance_info'] ?? null
                ], 422);
            }

            // Update all fields including validation status
            $oldValues = [
                'xcin_0' => $restitution->xcin_0,
                'montant' => $restitution->montant,
                'xvalsta_0' => $restitution->xvalsta_0
            ];
            
            $restitution->xcin_0 = $request->xcin_0;
            $restitution->montant = $request->montant;
            $restitution->xvalsta_0 = $request->xvalsta_0;
            
            Log::info("Saving restitution with updated values", [
                'xnum_0' => $restitution->xnum_0,
                'old_values' => $oldValues,
                'new_values' => [
                    'xcin_0' => $restitution->xcin_0,
                    'montant' => $restitution->montant,
                    'xvalsta_0' => $restitution->xvalsta_0
                ]
            ]);
            
            $saved = $restitution->save();
            
            Log::info("Restitution save result", [
                'xnum_0' => $restitution->xnum_0,
                'save_successful' => $saved,
                'final_xvalsta_0' => $restitution->fresh()->xvalsta_0 ?? 'failed to refresh'
            ]);

            // Trigger comprehensive balance recalculation when restitution is validated
            if ($request->xvalsta_0 == 2) {
                try {
                    Log::info("Starting balance recalculation for validated restitution", [
                        'client' => $restitution->xclient_0,
                        'site' => $restitution->xsite_0,
                        'restitution_amount' => $restitution->montant,
                        'xnum_0' => $restitution->xnum_0
                    ]);
                    
                    $newBalance = \App\Models\Csolde::recalculateBalance($restitution->xclient_0, $restitution->xsite_0);
                    
                    Log::info("Balance recalculation completed successfully", [
                        'client' => $restitution->xclient_0,
                        'site' => $restitution->xsite_0,
                        'new_balance' => $newBalance
                    ]);
                } catch (\Exception $e) {
                    Log::error("Error recalculating balance after restitution validation: " . $e->getMessage());
                    Log::error("Exception details: ", [
                        'client' => $restitution->xclient_0,
                        'site' => $restitution->xsite_0,
                        'exception' => $e
                    ]);
                    // Don't fail the validation just because of balance calculation error
                }
            }

            return response()->json(['message' => 'Récupération validée avec succès.']);
        } else {
            // For regular edits, only allow update if not validated
            if ($restitution->xvalsta_0 == 2) {
                return response()->json(['message' => 'Modification interdite : restitution validée.'], 403);
            }

            // Validate only the editable fields (CIN and Montant)
            $validator = Validator::make($request->all(), [
                'xcin_0' => [
                    'required',
                    'regex:/^[A-Za-z]{1,2}\d{4,8}$/'
                ],
                'montant' => 'required|numeric|min:0'
            ]);

            if ($validator->fails()) {
                return response()->json(['errors' => $validator->errors()], 422);
            }

            // Apply business logic validation for montant changes
            $validationResult = $this->validateRestitutionLogic(
                $restitution->xclient_0,
                $restitution->xsite_0,
                $request->montant
            );

            if (!$validationResult['success']) {
                return response()->json([
                    'success' => false,
                    'message' => $validationResult['message'],
                    'error_type' => $validationResult['error_type'] ?? 'validation_error',
                    'balance_info' => $validationResult['balance_info'] ?? null
                ], 422);
            }

            // Only update the allowed fields
            $restitution->xcin_0 = $request->xcin_0;
            $restitution->montant = $request->montant;
            $restitution->save();

            return response()->json(['message' => 'Récupération modifiée avec succès.']);
        }
    }public function destroy($xnum_0)
    {
        $restitution = Restitution::where('xnum_0', $xnum_0)->first();
        if (!$restitution) {
            return response()->json(['message' => 'Restitution non trouvée.'], 404);
        }

        // Check if restitution is validated (XVALSTA_0 = 2) - prevent deletion
        if ($restitution->xvalsta_0 == 2) {
            return response()->json(['message' => 'Suppression interdite : restitution validée.'], 403);
        }

        $restitution->delete();
        return response()->json(['message' => 'Restitution supprimée avec succès.']);
    }    public function generatePDF($xnum_0)
    {
        try {
            // Get the restitution record with related customer data
            $restitution = Restitution::where('xnum_0', $xnum_0)->firstOrFail();

            $pdf = PDF::loadView('pdf.bon-restitution', [
                'restitution' => $restitution
            ]);

            // Set paper size and orientation
            $pdf->setPaper('a4', 'portrait');

            // Set additional options for proper CSS loading
            $pdf->setOption('enable-local-file-access', true);
            $pdf->setOption('isRemoteEnabled', true);

            // Generate a filename based on the restitution number
            $filename = 'bon_restitution_' . $restitution->xnum_0 . '.pdf';

            // Return the PDF for download
            return $pdf->download($filename);

        } catch (\Exception $e) {
            Log::error("PDF Generation Error for xnum_0 '{$xnum_0}': " . $e->getMessage());
            return response()->json([
                'message' => 'Erreur lors de la génération du PDF',
                'error' => $e->getMessage()
            ], 500);
        }
    }
  public function previewPDF($xnum_0)
{
    try {
        // Récupérer la restitution
        $restitution = Restitution::where('xnum_0', $xnum_0)->firstOrFail();

        $client = $restitution->xclient_0;
        $site = $restitution->xsite_0;

        // Récupérer toutes les opérations validées
        $operations = collect()
            ->merge(Xcaution::where('xclient_0', $client)
                ->where('xsite_0', $site)
                ->where('xvalsta_0', 2)
                ->get()
                ->map(fn($op) => (object)[
                    'type' => 'Caution',
                    'created_at' => $op->created_at,
                    'montant' => $op->montant,
                ]))
            ->merge(Consignation::where('xclient_0', $client)
                ->where('xsite_0', $site)
                ->where('xvalsta_0', 2)
                ->get()
                ->map(fn($op) => (object)[
                    'type' => 'Consignation',
                    'created_at' => $op->created_at,
                    'palette_a_consigner' => $op->palette_a_consigner,
                ]))
            ->merge(Deconsignation::where('xclient_0', $client)
                ->where('xsite_0', $site)
                ->where('xvalsta_0', 2)
                ->get()
                ->map(fn($op) => (object)[
                    'type' => 'Déconsignation',
                    'created_at' => $op->created_at,
                    'palette_deconsignees' => $op->palette_deconsignees,
                ]))
            ->merge(Restitution::where('xclient_0', $client)
                ->where('xsite_0', $site)
                ->where('xvalsta_0', 2)
                ->get()
                ->map(fn($op) => (object)[
                    'type' => 'Restitution',
                    'created_at' => $op->created_at,
                    'montant' => $op->montant,
                    'is_current' => $op->xnum_0 === $xnum_0,
                ]));

        // Trier les opérations par date
        $sortedOps = $operations->sortBy('created_at')->values();

        // Initialisation des cumuls
        $cumulCaution = 0;
        $cumulConsignees = 0;
        $cumulDeconsignees = 0;
        $cumulRestitution = 0;

        $cautionBefore = 0;
        $cautionAfter = 0;

        foreach ($sortedOps as $op) {
            $isCurrent = $op->type === 'Restitution' && property_exists($op, 'is_current') && $op->is_current;

            // Stocker le solde juste avant le bon
            if ($isCurrent) {
                $cautionBefore = $cumulCaution - $cumulConsignees + $cumulDeconsignees - $cumulRestitution;
            }

            // Appliquer les opérations
            if ($op->type === 'Caution') {
                $cumulCaution += $op->montant ?? 0;
            } elseif ($op->type === 'Consignation') {
                $cumulConsignees += ($op->palette_a_consigner ?? 0) * 100;
            } elseif ($op->type === 'Déconsignation') {
                $cumulDeconsignees += ($op->palette_deconsignees ?? 0) * 100;
            } elseif ($op->type === 'Restitution') {
                $cumulRestitution += $op->montant ?? 0;
            }

            // Stocker le solde juste après le bon
            if ($isCurrent) {
                $cautionAfter = $cumulCaution - $cumulConsignees + $cumulDeconsignees - $cumulRestitution;
            }
        }

        // Générer le PDF
        $pdf = PDF::loadView('pdf.bon-restitution', [
            'restitution' => $restitution,
            'caution_before' => round($cautionBefore / 100, 2),
            'caution_after' => round($cautionAfter / 100, 2),
        ]);

        $pdf->setPaper('a4', 'portrait');
        $pdf->setOption('enable-local-file-access', true);
        $pdf->setOption('isRemoteEnabled', true);

        return $pdf->stream('bon_restitution_' . $restitution->xnum_0 . '.pdf');
    } catch (\Exception $e) {
        Log::error('PDF Generation Error: ' . $e->getMessage());
        return response()->json([
            'message' => 'Erreur lors de la génération du PDF',
            'error' => $e->getMessage()
        ], 500);
    }
}


    /**
     * Validate restitution business logic
     */
    private function validateRestitutionLogic($client, $site, $montant)
    {
        // Get current balance for the client/site
        $currentBalance = DB::table('csolde')
                           ->where('codeClient', $client)
                           ->where('site', $site)
                           ->value('solde') ?? 0;

        // Validation: Le montant de la récupération doit être inférieur ou égal au solde validé
        if ($currentBalance == 0) {
    return [
        'success' => false,
        'message' => "Aucune somme n'est disponible à récupérer, ni par le biais d'une déconsignation, ni par une caution déjà déposée.",
        'error_type' => 'no_balance',
        'balance_info' => [
            'current_balance' => $currentBalance,
            'requested_amount' => $montant,
            'client' => $client,
            'site' => $site
        ]
    ];
}

if ($montant > $currentBalance) {
    return [
        'success' => false,
        'message' => 'Le montant à récupérer dépasse votre solde.' . "\n\n" .
            'Il vous reste ' . number_format($currentBalance, 2, ',', ' ') . ' DH à récupérer.',
        'error_type' => 'insufficient_balance',
        'balance_info' => [
            'current_balance' => $currentBalance,
            'requested_amount' => $montant,
            'excess_amount' => $montant - $currentBalance,
            'client' => $client,
            'site' => $site
        ]
    ];
}

        // Validation réussie
        return [
            'success' => true,
            'message' => 'Validation réussie.',
            'balance_info' => [
                'current_balance' => $currentBalance,
                'requested_amount' => $montant,
                'remaining_balance' => $currentBalance - $montant,
                'client' => $client,
                'site' => $site
            ]
        ];
    }

    /**
     * Validate restitution data before saving
     */
    public function validateRestitution(Request $request)
    {
        try {
            $request->validate([
                'xclient_0' => 'required|string',
                'xsite_0' => 'required|string',
                'montant' => 'required|numeric|min:0.01'
            ]);

            $validationResult = $this->validateRestitutionLogic(
                $request->xclient_0,
                $request->xsite_0,
                $request->montant
            );

            if (!$validationResult['success']) {
                return response()->json([
                    'success' => false,
                    'message' => $validationResult['message'],
                    'error_type' => $validationResult['error_type'],
                    'balance_info' => $validationResult['balance_info'] ?? null
                ], 422);
            }

            return response()->json([
                'success' => true,
                'message' => 'Validation réussie',
                'balance_info' => $validationResult['balance_info'] ?? null
            ]);

        } catch (\Exception $e) {
            Log::error("Error in validateRestitution: " . $e->getMessage());
            return response()->json([
                'success' => false,
                'message' => 'Erreur lors de la validation: ' . $e->getMessage()
            ], 500);
        }
    }

    /**
     * Generate PDF report for restitutions within a specified XNUM_0 range
     */
    public function generateRangePDF(Request $request)
    {
        try {
            // Handle both POST and GET requests
            $data = $request->isMethod('post') ? $request->all() : $request->query();

            $validatedData = Validator::make($data, [
                'valeur_debut' => 'required|string',
                'valeur_fin' => 'required|string',
                'code_etat' => 'required|string',
                'description' => 'required|string',
                'filter_mode' => 'nullable|string',
                'filter_client_exact' => 'nullable|string',
                'filter_site_exact' => 'nullable|string'
            ])->validate();

            // Start with the base query
            $query = Restitution::where('xvalsta_0', 2);

            // Apply filtering based on mode
            if (isset($validatedData['filter_mode']) && $validatedData['filter_mode'] === 'specific') {
                // Specific client/site filtering
                if (isset($validatedData['filter_client_exact'])) {
                    $query->where('xclient_0', $validatedData['filter_client_exact']);
                }
                if (isset($validatedData['filter_site_exact'])) {
                    $query->where('xsite_0', $validatedData['filter_site_exact']);
                }
            } else {
                // Default range-based filtering
                $query->where('xnum_0', '>=', $validatedData['valeur_debut'])
                      ->where('xnum_0', '<=', $validatedData['valeur_fin']);
            }

            $restitutions = $query->orderBy('xnum_0')->get();

            if ($restitutions->isEmpty()) {
                return response()->json([
                    'message' => 'Aucune restitution validée trouvée dans cette plage.'
                ], 404);
            }

            $pdf = PDF::loadView('pdf.bon-restitution-multiple', [
                'restitutions' => $restitutions,
                'valeur_debut' => $validatedData['valeur_debut'],
                'valeur_fin' => $validatedData['valeur_fin'],
                'code_etat' => $validatedData['code_etat'],
                'description' => $validatedData['description'],
                'date_generation' => now()->format('d/m/Y H:i:s'),
                'filter_mode' => $validatedData['filter_mode'] ?? 'range',
                'filter_client' => $validatedData['filter_client_exact'] ?? null,
                'filter_site' => $validatedData['filter_site_exact'] ?? null
            ]);

            $pdf->setPaper('a4', 'portrait');

            // Generate filename based on filter mode
            $filename = "etat_restitutions";
            if (isset($validatedData['filter_mode']) && $validatedData['filter_mode'] === 'specific') {
                if (isset($validatedData['filter_client_exact'])) {
                    $filename .= "_client_{$validatedData['filter_client_exact']}";
                }
                if (isset($validatedData['filter_site_exact'])) {
                    $filename .= "_site_{$validatedData['filter_site_exact']}";
                }
            } else {
                $filename .= "_{$validatedData['valeur_debut']}_{$validatedData['valeur_fin']}";
            }
            $filename .= ".pdf";

            return $pdf->stream($filename);

        } catch (\Exception $e) {
            Log::error('Error generating restitutions range PDF: ' . $e->getMessage());
            return response()->json([
                'message' => 'Erreur lors de la génération du PDF',
                'error' => $e->getMessage()
            ], 500);
        }
    }

    /**
     * Get CIN by client code from the most recent validated caution
     */
    public function getCinByClient($clientCode)
    {
        $caution = Xcaution::where('xclient_0', $clientCode)
            ->where('xvalsta_0', 2) // Only get validated cautions
            ->orderByDesc('created_at')
            ->first();
        
        if (!$caution) {
            return response()->json(['message' => 'Aucune caution validée trouvée pour ce client.'], 404);
        }
        
        return response()->json(['xcin_0' => $caution->xcin_0]);
    }
}
